import cv2
import numpy
import math
from enum import Enum

class Contours:

    """
    An OpenCV pipeline generated by GRIP.
    """
    
    def __init__(self):
        """initializes all values to presets or None if need to be set
        """

        self.__blur_type = BlurType.Gaussian_Blur
        self.__blur_radius = 1.7809910068770947

        self.blur_output = None

        self.__hsv_threshold_input = self.blur_output
        self.__hsv_threshold_hue = [14, 47]
        self.__hsv_threshold_saturation = [113, 248]
        self.__hsv_threshold_value = [128, 288]

        self.hsv_threshold_output = None

        self.__find_contours_input = self.hsv_threshold_output
        self.__find_contours_external_only = True

        self.find_contours_output = None

        self.__convex_hulls_contours = None

        self.__circles_min_radius = 100


    def process(self, source0):
        """
        Runs the pipeline and sets all outputs to new values.
        """
        # Step Blur0:
        self.__blur_input = source0
        (self.blur_output) = self.__blur(self.__blur_input, self.__blur_type, self.__blur_radius)

        # Step HSV_Threshold0:
        self.__hsv_threshold_input = self.blur_output
        (self.hsv_threshold_output) = self.__hsv_threshold(self.__hsv_threshold_input, self.__hsv_threshold_hue, self.__hsv_threshold_saturation, self.__hsv_threshold_value)
        cv2.imshow("threshold", self.hsv_threshold_output)

        # Step Find_Contours0:
        self.__find_contours_input = self.hsv_threshold_output
        (self.find_contours_output) = self.__find_contours(self.__find_contours_input, self.__find_contours_external_only)

        # Approximate contours to polygons + get bounding rects and circles

        contours_poly = [None]*len(self.find_contours_output)
        boundRects = [None]*len(self.find_contours_output)
        centers = [None]*len(self.find_contours_output)
        radii = [None]*len(self.find_contours_output)
        for i, c in enumerate(self.find_contours_output):
            contours_poly[i] = cv2.approxPolyDP(c, 3, True)
            boundRects[i] = cv2.boundingRect(contours_poly[i])
            centers[i], radii[i] = cv2.minEnclosingCircle(contours_poly[i])

        return (self.find_contours_output, boundRects, centers, radii)



    @staticmethod
    def __blur(src, type, radius):
        """Softens an image using one of several filters.
        Args:
            src: The source mat (numpy.ndarray).
            type: The blurType to perform represented as an int.
            radius: The radius for the blur as a float.
        Returns:
            A numpy.ndarray that has been blurred.
        """
        if(type is BlurType.Box_Blur):
            ksize = int(2 * round(radius) + 1)
            return cv2.blur(src, (ksize, ksize))
        elif(type is BlurType.Gaussian_Blur):
            ksize = int(6 * round(radius) + 1)
            return cv2.GaussianBlur(src, (ksize, ksize), round(radius))
        elif(type is BlurType.Median_Filter):
            ksize = int(2 * round(radius) + 1)
            return cv2.medianBlur(src, ksize)
        else:
            return cv2.bilateralFilter(src, -1, round(radius), round(radius))

    @staticmethod
    def __hsv_threshold(input, hue, sat, val):
        """Segment an image based on hue, saturation, and value ranges.
        Args:
            input: A BGR numpy.ndarray.
            hue: A list of two numbers the are the min and max hue.
            sat: A list of two numbers the are the min and max saturation.
            lum: A list of two numbers the are the min and max value.
        Returns:
            A black and white numpy.ndarray.
        """
        out = cv2.cvtColor(input, cv2.COLOR_BGR2HSV)
        return cv2.inRange(out, (hue[0], sat[0], val[0]),  (hue[1], sat[1], val[1]))

    @staticmethod
    def __find_contours(input, external_only):
        """Sets the values of pixels in a binary image to their distance to the nearest black pixel.
        Args:
            input: A numpy.ndarray.
            external_only: A boolean. If true only external contours are found.
        Return:
            A list of numpy.ndarray where each one represents a contour.
        """
        if(external_only):
            mode = cv2.RETR_EXTERNAL
        else:
            mode = cv2.RETR_LIST
        method = cv2.CHAIN_APPROX_SIMPLE
        # xyz = cv2.findContours(input, mode=mode, method=method)
        contours, hierarchy =cv2.findContours(input, mode=mode, method=method)

        return contours
    

    def detect(self, imageFrame, depthFrame, depthFrameColor):
        (contours, boundRects, centers, radii) = self.process(imageFrame)
        objects = []
        for i, c in enumerate(centers):
            if radii[i] < self.__circles_min_radius:
                continue

            # draw the center (x, y)-coordinates of the AprilTag
            (cX, cY) = (int(c[0]), int(c[1]))
            cv2.circle(imageFrame, (cX, cY), 5, (0, 0, 255), -1)
            cv2.circle(imageFrame, (cX, cY), int(radii[i]), (255, 0, 0), 2)
            # # draw the tag family on the image
            # tagID= '{}: {}'.format(r.tag_family.decode("utf-8"), r.tag_id)
            # color = (255, 0, 0)
            # cv2.putText(imageFrame, tagID, (lblX, lblY - 60), cv2.FONT_HERSHEY_TRIPLEX, 0.5, color)
            # cv2.putText(imageFrame, f"X: {atX} {units}", (lblX, lblY - 45), cv2.FONT_HERSHEY_TRIPLEX, 0.5, color)
            # cv2.putText(imageFrame, f"Y: {atY} {units}", (lblX, lblY - 30), cv2.FONT_HERSHEY_TRIPLEX, 0.5, color)
            # cv2.putText(imageFrame, f"Z: {atZ} {units}", (lblX, lblY - 15), cv2.FONT_HERSHEY_TRIPLEX, 0.5, color)

            objects.append({"objectLabel": f"blob{i}", "x": c[0], "y": c[1], "r": radii[i]}) 
        return objects
    

BlurType = Enum('BlurType', 'Box_Blur Gaussian_Blur Median_Filter Bilateral_Filter')

